<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>QC Analyzer â€” Robust Client-side OCR</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
  <style>
    :root{--bg:#f7f9fc;--card:#fff;--muted:#6b7280;--accent:#0366d6;--danger:#c02616;--success:#0f766e;--radius:12px}
    body{background:var(--bg);margin:0;padding:14px;font-family:Inter,system-ui,Roboto,Arial;color:#111}
    .container{max-width:980px;margin:0 auto}
    .card{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(12,38,63,0.06);margin-bottom:12px}
    h1{margin:0;font-size:1.25rem}
    .upload-btn{display:inline-block;padding:12px;border-radius:10px;border:2px dashed #d1d5db;background:#fff;cursor:pointer;font-weight:700;color:var(--accent)}
    input[type=file]{display:none}
    .hint{color:var(--muted);margin-top:8px;font-size:0.9rem}
    .preview{margin-top:12px;border-radius:8px;overflow:hidden;border:1px solid #eee}
    .preview img{width:100%;display:block}
    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:0.9rem;color:var(--muted)}
    .status{margin-top:10px;font-size:0.95rem;color:#333}
    .progress{height:8px;background:#eef2ff;border-radius:999px;overflow:hidden;margin-top:8px}
    .progress > span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#5aa0ff);width:0%}
    pre.debug{background:#0b1220;color:#e6f0ff;padding:8px;border-radius:8px;max-height:180px;overflow:auto;font-size:0.8rem}
    button.primary{background:var(--accent);color:#fff;border:none;padding:8px 10px;border-radius:8px;cursor:pointer}
    button.ghost{background:#fff;border:1px solid #ddd;padding:8px 10px;border-radius:8px;cursor:pointer}
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>AI QC Analyzer â€” Robust OCR</h1>
      <div class="hint">Upload a clear screenshot of the QC table (Test / Result / Mean / SD). OCR runs in your browser â€” nothing is uploaded.</div>

      <div style="margin-top:12px" class="row">
        <label for="fileinput" class="upload-btn">ðŸ“¤ Click here to upload QC image</label>
        <input id="fileinput" type="file" accept="image/*">
        <button id="startBtn" class="primary" style="margin-left:auto">Start OCR</button>
      </div>

      <div class="hint">Tip: crop to just the table numeric columns for best results. If OCR doesn't start automatically, tap <em>Start OCR</em>.</div>

      <div id="status" class="status small">Initializing OCR engine â€” please waitâ€¦</div>
      <div class="progress" id="prog" style="display:none"><span id="progFill"></span></div>

      <div id="preview" class="preview" style="display:none"></div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px 0">Extracted table (best effort)</h3>
      <div id="resultArea" class="small">No image processed yet.</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px 0">Westgard findings</h3>
      <div id="findings" class="small">No findings yet.</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px 0">Debug / Logs</h3>
      <div><strong class="small">Status messages:</strong></div>
      <pre id="log" class="debug">waiting...</pre>
    </div>
  </div>

<script>
(async () => {
  // UI refs
  const fileInput = document.getElementById('fileinput');
  const preview = document.getElementById('preview');
  const status = document.getElementById('status');
  const prog = document.getElementById('prog');
  const progFill = document.getElementById('progFill');
  const resultArea = document.getElementById('resultArea');
  const findings = document.getElementById('findings');
  const logBox = document.getElementById('log');
  const startBtn = document.getElementById('startBtn');

  // logging helpers
  function log(s) { console.log(s); logBox.textContent = (new Date()).toLocaleTimeString() + " â€” " + s + "\n" + logBox.textContent; }
  function setStatus(s){ status.textContent = s; log(s); }
  function showProgressValue(p){ prog.style.display='block'; progFill.style.width = Math.round(p*100)+'%'; }
  function hideProgress(){ prog.style.display='none'; progFill.style.width = '0%'; }

  // create worker with langPath CDN to avoid fetch issues
  const worker = Tesseract.createWorker({
    logger: m => {
      if (m && m.status) {
        const pct = m.progress ? Math.round(m.progress*100) : '';
        setStatus(`${m.status}${pct ? ' â€” ' + pct + '%' : ''}`);
        if (typeof m.progress === 'number') showProgressValue(m.progress);
      }
    },
    langPath: 'https://tessdata.projectnaptha.com/4.0.0'
  });

  // initialize worker
  try {
    setStatus('Loading OCR engine (this may take a few seconds)...');
    log('worker.load()');
    await worker.load();
    log('worker.loadLanguage(eng)');
    await worker.loadLanguage('eng');
    log('worker.initialize(eng)');
    await worker.initialize('eng');
    setStatus('OCR ready. Upload an image or press Start OCR after selecting one.');
  } catch (e) {
    setStatus('OCR init failed: ' + (e.message || e));
    log('OCR init error: ' + e);
  }

  // downscale large images for mobile
  async function downscaleImage(file, maxDim=1200){
    return new Promise((res, rej) => {
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.onload = () => {
        let {width:w, height:h} = img;
        let scale = Math.min(1, maxDim / Math.max(w,h));
        if (scale < 1) { w = Math.round(w*scale); h = Math.round(h*scale); }
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, w, h);
        canvas.toBlob(blob => {
          URL.revokeObjectURL(url);
          res({blob, previewImg: canvas.toDataURL('image/jpeg', 0.85)});
        }, 'image/jpeg', 0.85);
      };
      img.onerror = (err) => {
        URL.revokeObjectURL(url);
        rej(err);
      };
      img.src = url;
    });
  }

  // parse OCR text heuristically into rows
  function parseTextToRows(raw) {
    if (!raw) return [];
    const lines = raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const rows = [];
    for (let ln of lines) {
      if (/mean|sd|result|test|flag|sr|lot|consumable|curve|interval/i.test(ln)) continue;
      const nums = ln.match(/[-+]?\d*\.?\d+/g) || [];
      const toks = ln.split(/\s+/);
      const testTok = toks.find(t => /[A-Za-z]/.test(t)) || 'UNKNOWN';
      let result=null, mean=null, sd=null;
      if (nums.length>=3) {
        result = parseFloat(nums[nums.length-3]);
        mean   = parseFloat(nums[nums.length-2]);
        sd     = parseFloat(nums[nums.length-1]);
      }
      rows.push({test:testTok.toUpperCase(), result, mean, sd, raw:ln});
    }
    return rows;
  }

  // Westgard checks
  function applyWestgard(rows) {
    const flags = [];
    rows.forEach((r) => {
      if (r.result == null || r.mean == null || r.sd == null || r.sd <= 0) return;
      const z = (r.result - r.mean) / r.sd;
      if (Math.abs(z) > 3) flags.push({test:r.test, rule:'1:3s Violation', z});
      else if (Math.abs(z) > 2) flags.push({test:r.test, rule:'1:2s Warning', z});
    });
    return flags;
  }

  function renderRows(rows, rawText) {
    if (!rows.length) {
      resultArea.innerHTML = '<div class="small">No rows detected. Try cropping to the numeric columns and re-upload.</div>';
      return;
    }
    let html = '<table style="width:100%;border-collapse:collapse"><thead><tr style="background:#fafafa"><th style="padding:6px">Test</th><th>Result</th><th>Mean</th><th>SD</th></tr></thead><tbody>';
    rows.forEach(r => {
      html += `<tr><td style="padding:6px">${escapeHtml(r.test)}</td><td>${r.result ?? '-'}</td><td>${r.mean ?? '-'}</td><td>${r.sd ?? '-'}</td></tr>`;
    });
    html += `</tbody></table><div style="margin-top:8px" class="small">Raw OCR sample: ${escapeHtml(rawText.slice(0,400))}</div>`;
    resultArea.innerHTML = html;
  }
  function renderFindings(flags) {
    if (!flags.length) { findings.innerHTML = '<div style="color:green;font-weight:700">No Westgard violations detected.</div>'; return; }
    let html = '<ul style="padding-left:18px;margin:0">';
    flags.forEach(f => {
      const cls = f.rule.includes('3s') ? 'color:#c02616' : 'color:#b45309';
      html += `<li style="margin-bottom:6px"><span style="${cls};font-weight:700">${escapeHtml(f.test)} â€” ${escapeHtml(f.rule)}</span> <span class="small"> (z=${f.z.toFixed(2)})</span></li>`;
    });
    html += '</ul>';
    findings.innerHTML = html;
  }
  function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // ----- CORRECTED doOCR(): use worker.recognize(...) properly -----
  async function doOCR(blobOrImage) {
    try {
      setStatus('Starting OCR (recognition)â€¦');
      showProgressValue(0.02);

      // CORRECT worker API usage:
      const { data } = await worker.recognize(blobOrImage);

      showProgressValue(1);
      hideProgress();
      setStatus('OCR complete â€” parsing text');

      const raw = data.text || '';
      const rows = parseTextToRows(raw);
      renderRows(rows, raw);
      renderFindings(applyWestgard(rows));

    } catch (err) {
      hideProgress();
      setStatus('OCR failed: ' + (err.message || err), false);
      log('OCR error: ' + err);
      resultArea.innerHTML = '<div class="small">OCR failed. Try cropping to numeric columns or use a different photo.</div>';
      findings.innerHTML = '';
    }
  }

  // file handling / auto-run OCR
  let lastPrepared = null;
  fileInput.addEventListener('change', async (evt) => {
    const f = evt.target.files && evt.target.files[0];
    if (!f) return;
    setStatus('Image selected. Preparing (downscaling) â€” please wait');
    showProgressValue(0.02);
    try {
      const prepared = await downscaleImage(f, 1200);
      lastPrepared = prepared;
      preview.style.display = 'block';
      preview.innerHTML = `<img src="${prepared.previewImg}" alt="preview">`;
      setStatus('Image ready. Tap Start OCR to begin (or it will auto-run shortly)...');
      hideProgress();
      setTimeout(() => {
        if (lastPrepared === prepared) { startOCR(); }
      }, 900);
    } catch (e) {
      hideProgress();
      setStatus('Image preparation failed: ' + (e.message || e), false);
      log('downscale error: ' + e);
    }
  });

  async function startOCR() {
    if (!lastPrepared) { setStatus('No image selected. Please choose an image first.', false); return; }
    setStatus('Running OCR â€” this may take 10â€“60s depending on device');
    showProgressValue(0.05);
    await doOCR(lastPrepared.blob);
  }
  startBtn.addEventListener('click', startOCR);

  // cleanup on page unload
  window.addEventListener('beforeunload', async () => {
    try { await worker.terminate(); } catch(e) {/*ignore*/}
  });

  // helper: show/hide progress
  function showProgressValue(p){ prog.style.display='block'; progFill.style.width = String(Math.round((p||0)*100)) + '%'; }
  function hideProgress(){ prog.style.display='none'; progFill.style.width='0%'; }

  // initial status
  setStatus('Ready. Please upload a QC image.');
})();
</script>
</body>
</html>
